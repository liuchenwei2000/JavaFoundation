## RTTI 简介 ##

运行时类型识别(run-time type identification)：当只有一个指向对象基类的引用时，RTTI机制可以找出对象的确切类型。

主要有两种方式：

* 1，"传统的"RTTI,假定编译时和运行时已经知道了所有的类型

如(Classname)这种强制类型转换，RTTI确保类型转换的正确性，如果执行一个错误的类型转换就会抛出一个ClassCastException。

* 2，"反射"机制，允许在运行时获得类的信息

RTTI的存在原因：让代码只操纵对基类的引用

这样如果要添加新的子类来扩展程序就不会影响到原来的代码，因此通常会创建一个具体子类对象，把它向上转型成基类，忽略其具体类型，并在后面的程序中使用匿名（即不知道具体类型）的基类引用，通常希望大部分的代码尽可能少地了解对象的具体类型，而是只与对象家族中的一个通用表示打交道。这样代码会更容易写，更容易读，更容易维护，所以"多态"是面向对象编程的基本目标。

面向对象编程语言的目的是，在凡是可以使用的地方都使用多态机制，只在必需的时候使用RTTI，然而使用多态机制的方法调用，要求拥有基类定义的控制权。因为在扩展程序的时候可能会发现基类并未包含想要的方法，如果基类是别人的类，或者由别人控制，这时候RTTI便是一种解决之道：可继承一个新类，然后添加需要的方法，在代码的其他地方，可以检查特定的类型，并调用自己的方法。这样做不会破坏多态性以及程序的扩展能力，因为这样添加一个新的类并不需要在程序中搜索switch语句。但如果在程序主体中添加需要的新特性的代码，就必须使用RTTI来检查特定类型。
