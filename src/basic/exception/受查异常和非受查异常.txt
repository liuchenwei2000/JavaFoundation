                                                                                        受 查 异 常 和 非 受 查 异 常

Java语言规范将派生于RuntimeException类或Error类的所有异常称为 未检查或非受查(unchecked)异常，其他的异常成为 已检查或受查(checked)异常。
编译器将核查是否为所有已检查异常提供了异常处理器。RuntimeException这个名字很容易让人混淆，实际上所有的错误都发生在运行时刻。

如果出现RuntimeException异常，就一定是你的问题――――这是一条相当有道理的规则。

如果遇到了无法处理的情况，Java的方法可以抛出一个异常。一个方法不仅要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。
因为任何一个抛出异常的方法都有可能是一个死亡陷阱。如果没有处理器捕获这个异常，当前执行的线程就会被中断。

一个方法必须声明所有可能抛出的 已检查异常，而 未检查异常 要么不可控制(Error)，要么就应该避免它们的发生(RuntimeException)。

通常，应该捕获那些知道如何处理的异常，而将不知道如何处理的异常传递出去。

产生受查异常的语句必须在try-catch块中，产生非受查异常的语句无需在try-catch块中。
但是可以添加自己的程序语句捕获异常然后抛出给上层方法或者直接处理异常。

受查异常是编译器强制实施的，某方法中若有受查异常被抛出则必须在方法头用throws声明抛出的具体异常类型。
非受查异常编译器不需要声明，其输出被报告给了System.err，可以在代码中忽略非受查异常。

Java鼓励把方法可能会抛出的异常告知使用此方法的客户端程序员，这是优雅的做法，因为程序库通常并不与源代码一起发布。
即使一个方法并不会抛出异常最好也是在声明方法的时候使用throws表明会有异常(异常的类型尽可能明确)。
这样在以后修改代码(若有异常)的时候就不必担心客户端了，在定义抽象基类和接口的时候这样很重要，这样派生类或接口实现就能够抛出这些预先声明的异常。

代码必须与异常说明保持一致，如果方法里的代码产生了异常却没有进行处理。
编译器会发现这个问题并提醒你：要么处理这个异常，要么就在异常说明中表明此方法将产生异常。
通过这种自顶向下强制执行的异常说明机制，Java在编译时就可以保证一定水平的异常正确性。

永远不必为异常对象的清理而担心，它们都是用new在堆上创建的对象，所以垃圾回收器会自动把它们清理掉。