                           final 关 键 字 详 解
              
使用final只有三种情况：数据、方法和类。

1，final 数据

一个既是static又是final的数据只占据一段不能改变的存储空间(编译期常量)。对于基本类型final使数值恒定不变；而用于对象引用，final使引用恒定不变。
一旦引用被初始化指向一个对象，就无法再把它改为指向别的对象，但是对象本身却是可以修改的，Java并未提供使任何对象恒定不变的途径

final修饰符大都应用于基本类型(primitive)域，或不可变(immutable)类的域。对于可变的类，使用final修饰符可能会造成混乱：
private final Date date;
仅仅意味着存储在date变量中的对象引用在对象构造之后不能被改变，而并不意味着date对象是一个常量，因为对date对象调用任何Date类的方法都有可能改变这个对象。

Java允许生成"空白final"，它是指被声明为final但又未给初值的数据，编译期能确保空白final在使用前必须被初始化，
空白final在关键字final的使用上提供了更大的灵活性，如一个类中的final域可以做到根据对象而有所不同却又保持其恒定不变的特性。

public class Demo{

    private final int id;// 空白final
    
    // 空白final必须造构造方法中被初始化
    public Demo(int myid){
        id = myid;
    }
}

Java允许在参数列表中以声明的方式将参数指明为final，这意味着在方法中无法改变参数引用所指向的对象，这个特性主要用来向匿名内部类传递数据。


2，final 方法

为了将方法锁定，以防任何继承类修改它的含义。这是出于设计的考虑，想要确保在继承中使用方法行为保持不变，并且不会被覆盖。

类中所有的private方法都隐式地指定为final，由于无法取用private方法也就无法覆盖它。
"覆盖"只有在某方法是基类的接口的一部分时才会出现，即必须能将一个对象向上转型为它的基本类型并调用相同的方法。
如果某方法为private，它就不是基类的接口的一部分，它仅仅是隐藏于类中的程序代码。
由于private方法无法触及而且能有效隐藏，所以除了把它看成是因为它所归属的类的组织结构的原因而存在外，其他任何事物都不需要考虑到它。


3，final 类
当将某个类的整体定义为final时，这就表明该类不能被继承，这可能是处于设计或者安全的考虑，它不希望有子类。
