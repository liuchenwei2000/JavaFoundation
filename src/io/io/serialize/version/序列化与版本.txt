                                                                             序 列 化 与 版 本

Java可以使用检查类指纹（使用SHA算法计算）的方法来避免下述情况：
一个对象被保存在一个磁盘文件。后来，类的设计者做了一些改变，比如删除了一个字段。
于是旧的磁盘文件被再次读取。此时，磁盘上的数据布局不再与内存中的数据布局相符合。
如果用旧的形式读回数据，便可能会破坏内存。Java非常小心地保证不会发生内存被破坏的情况。

为了做到这一点，Java使用类指纹检查，以保证类的定义在恢复一个对象时没有改变。
实际上，它是通过比较磁盘文件中保存的指纹和目前的类的指纹实现的。


当将对象序列化到磁盘之后，如果程序版本发生了变化。那么就引发了两个问题：
低版本的程序能否反序列化读取高版本序列化的对象；高版本的程序能否反序列化读取低版本序列化的对象。

很显然我们都希望对象文件能与类升级同步。因为如果类的定义发生了任何形式的变化，其SHA指纹也会改变。
这样对象流会拒绝读取任何与指纹有异的对象。然而类也可以指出自己兼容于其早期版本，为了实现这一点，首先必须获得该类的早期版本的指纹。
可以使用一个独立的程序 serialver（它是JDK的一部分）来获得这个数值（一般的IDE可以自动的获取这个值）。

如：
private static final long serialVersionUID = -4354200758987066819L;

所有的后续版本的类都必须把serialVersionUID常量和原来的指纹定义成一样的。
当一个类具有一个名为serialVersionUID的静态数据成员时，它将不会再次计算指纹，而只是使用这个值。
一旦serialVersionUID这个静态数据成员被放入类中，通过序列化系统就可以读取那个类的不同版本的对象。

如果只有类的方法变换了，新对象数据的读取不会有丝毫问题。然而如果数据字段发生了变化，就可能会出现问题。
例如，旧的文件对象拥有的数据字段可能多于或者少于程序中拥有的数据字段，或者数据字段的类型已发生了改变。
在这种情况下，对象流会尝试将流对象转化为当前版本的类。

对象流会将当前版本类中的数据字段和流中的数据字段做比较。当然，对象流考虑的只是非临时和非静态的数据字段。
如果两个字段名称匹配而类型不同，则对象流不会进行类型的转换--对象是不兼容的。
如果流内的对象有当前版本不存在的数据字段，那么对象流会忽略该数据。
假如当前版本拥有的数据字段在对象流中不存在，则增加的字段会设置为默认值（对象是null，数字是0，boolean为false）。
这种默认的处理也许不那么安全，所以还要由类的设计者在readObject方法中增加代码来实现版本的兼容，或者确保方法具有足够的健壮性来处理那些null数据。
