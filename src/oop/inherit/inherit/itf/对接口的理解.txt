                                                                                                                         对接口的理解


接口的命名一般以able作为结尾，意味可……的
接口中的方法不可以被native, synchronized, strictfp, static, final修饰
因为这些方法是不关心实现的，并且都是抽象的
(若一个接口不是public的而是包级访问权限的，则它只能在包内使用)

使用接口的两个重要原因是：
1，为了能够向上转型为多个基类型以及由此带来的灵活性
也就是实现了多个接口达到多重继承的目的
2，与使用抽象类一样，防止客户端程序员创建该类的实例
如果知道某事物应该成为一个基类，那么第一选择是使其成为一个接口
3，有时候拘泥于单继承体系会使程序受限很多
如果方法的参数是一个接口，而不是一个类，这种限制就放松了许多
因为任何实现了该接口的类都能满足该方法，也包括当时不存在的类
这就给予客户端程序员一种选择，他可以通过实现一个接口来满足类或方法
因此，接口允许我们快捷地实现类继承，也使得创建一个新类来做到这一点

接口的其他用途：
因为接口中的任何字段都自动的是public static final
所以可以用来很便捷的创建常量组，但这些字段不是接口的一部分
只是被存储在该接口的静态存储区域内(现在可以被Enum取代) 
当接口中的任何字段首次被访问时接口被JVM加载并且初始化所有数据

有些接口中没有任何的常量和方法，就像是Cloneable接口似的
这种接口被称为Marker Interface，用来标明实现类应具有的属性或者机制
这是一种退化了的契约，一般会在相关文档中对该接口做出详细解释

在设计中这种接口有着重要的作用和影响，并不能因为它们没有方法和常量而认为它们不重要

对接口的一些建议：
1，可以将接口方法标记为public，将常量标记为public static final。
有些程序员出于习惯或高清晰度的考虑，愿意这样做。但Java语言规范却建议不要书写这些多余的关键字。

2，常量接口只定义常量而没有任何方法，类为了能够简洁的引用接口中的常量而去实现这个接口的确可行
但是这样应用接口似乎有点偏离接口概念的初衷，不建议这样做。

3，标记接口没有方法，使用它的唯一目的是可以用instanceof进行类型检查。
建议在编写程序时，不要使用这种技术。

例子：

对于不同的数据库，都需要被程序连接，连接方法是不一样的。
在某个环境下，我们只知道有个数据库，但不知道是怎么连接的，只知道能连接
                             
数据库连接接口：
interface DatabaseConnection
{
  void connect();//连接数据库的方法
}

SQLServer数据库实现这个接口：
class SQLServer interface DatabaseConnection
{
  void connect()
  {
  //SQLServer的具体连接方法
  }
}

Oracle数据库实现这个接口
class Oracle interface DatabaseConnection
{
  void connect()
  {
  //Oracle的具体连接方法
  }
}

在某个环境下，比如在某个类中：
Class Test
{
  //这个方法只管连接数据库
  //具体何种数据库由实际情况确定
  void connectToDB(DatabaseConnection dbc)
  {
  dbc.connect();
  //传SQLServer的对象进来就用SQLServer的connect()方法
  //传Oracle的对象进来就用SQLServer的connect()方法
  }
}     