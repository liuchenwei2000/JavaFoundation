当软件系统中出现了形式相似、本质相同的类的时候
我们需要把这些类的共性拿出来，放到比这些类更高一层的地方，
做为这些类的父类(super class)，而将它们的不同保留在这些类中
最后，让这些类都去继承共性的父类，以消除重复定义的代码。
在现实中，也有很多相似的情形。
比如：如果我们进行一个图形编辑软件的开发
就会发现在这个软件系统中存在着圆、三角形等等一些具体概念
它们是不同的，但是它们又都属于形状这样一个概念
而形状这一概念不能以一种具体形式出现在在软件系统中，那么它就是一个抽象概念。
正是因为抽象的概念在系统中没有具体的Object与其对应，
所以用以表征抽象概念的抽象的类是不能够实例化的。

在OO的程序设计过程中，抽象的类主要用来进行类的共性的提取
我们可以构造出一个固定的一组行为的抽象定义
但是对于这一组行为，每个不同的种类又可能有自己不同的实现方式
这组抽象定义集合起来就是我们通常所说的抽象的类
而派生的非抽象的类中则定义了这一组可能的具体实现

abstract class在Java语言中体现了一种继承关系
要想使得继承关系合理，父类和派生类之间必须存在"is a"关系
也就是说，派生类是父类的一个具体形式，或者是在某一特定情况下的体现
对于interface来说则不然
并不要求interface的实现者和interface定义在概念本质上是一致的
仅仅是实现了interface定义的契约而已
换一句话说，就是实现了接口的类和被实现的接口之间的关系是一个"has a function"的关系