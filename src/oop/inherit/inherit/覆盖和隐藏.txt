                                                                                                                       继 承 和 覆 盖

子类可以继承父类的所有public和protected的成员和方法，不能继承包级私有和private的成员和方法，如果子类和父类在同一个包内则可以继承包级私有的成员和方法。
如果子类中有字段或静态方法和父类同名，则父类的就被隐藏了(不赞成这样)，父类的私有方法和静态方法不能被子类覆盖，只能被隐藏。

overload：
编译器根据参数列表(参数数目、类型、顺序等)来区分各个方法而返回类型不包括在内。

override:
首先父类的方法必须具有一定的可见性(至少是protected)。
若方法可见性是private，那么子类是无法继承它的，更不可能覆盖它，即使子类中有和它一摸一样的方法也和父类中的方法没有任何关系。
若子类可继承还必须保证方法名和参数列是一致的(不能用数组替代不定长参数列，反之亦然)

访问控制：子类的方法只能维持或者扩大可见度。
异常抛出：子类的方法只能抛出父类声明抛出的异常或者子异常，并且抛出的异常种类数目可以比父类少，甚至没有。
返回类型：子类的方法只能返回父类的返回类型或者其子类型。

子类完全可以把一个父类已经实现的方法覆盖为abstract方法。

static成员(字段和方法)都不允许覆盖，但如果子类中有同名的static成员，则父类的该成员被隐藏了。


父类的一个引用可以指向任何从该父类派生的子类对象，引用变量的类型而不是引用对象的类型决定了什么成员可以被访问。
即：当一个子类对象的引用被赋给一个父类引用变量时，只能访问父类定义的字段和方法；但是被引用对象的类型而不是引用变量的类型决定执行哪个定义的方法。
也就是说，决定调用哪个定义的方法取决于对象的真正的类型(type)。

