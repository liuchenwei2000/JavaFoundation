                                                                                                                       继 承 和 覆 盖


一，
子类可以继承父类的所有public和protected的成员和方法
不能继承包级私有和private的成员和方法
如果子类和父类在同一个包内则可以继承包级私有的成员和方法
如果在子类中有字段或静态方法和父类同名，则父类的就被隐藏了(不赞成这样)
父类的私有方法和静态方法将会被阻止让子类覆盖，只能被隐藏

override方法的注意事项：
首先父类的方法必须具有一定的可见性(至少是protected)
若可见性是private，那么子类是无法继承它的，更不可能覆盖它
即使子类中有和它一摸一样的方法也和父类中的方法没有任何关系
(对private方法的调用一般是调用的它所定义的类中的实现)
若子类可继承还必须保证方法名和参数列是一致的(不能用数组替代不定长参数列，反之亦然)
访问控制：子类的方法只能维持或者扩大可见度
异常抛出：子类的方法只能抛出父类声明抛出的异常或者子异常
         并且抛出的异常种类数目可以比父类少，甚至没有
返回类型：子类的方法只能返回父类的返回类型或者其子类型
子类完全可以把一个父类已经实现的方法覆盖为abstract方法

overload：
编译器根据参数列表(参数数目、类型、顺序等)来区分各个方法而返回类型不包括在内
override:
父类的static方法可以被继承但是不可以被覆盖为非static方法
static成员(字段和方法)都不允许覆盖，但如果子类中有同名的static成员，则父类的该成员被隐藏了

二，
super的用途：
1，调用超类的构造函数
2，访问被子类成员隐藏的超类成员(字段和方法)

三，
当创建一个子类的对象时，该对象包含了一个基类的子对象
Java会自动在子类的每一个构造方法中插入对基类无参构造方法的调用
除非它已经调用了基类其他有参数的构造方法，调用一个带参数的基类构造器
就必须用super关键字显式调用并配以适当的参数列表
调用基类构造方法必须是在子类的构造方法中要做的第一件事
并且子类的每个构造方法中有且只能有一个super关键字

四，
超类变量可以引用子类对象：
超类的一个引用对象可以被任何从该超类派生的子类的引用赋值
引用变量的类型而不是引用对象的类型决定了什么成员可以被访问
即：当一个子类对象的引用被赋给一个超类引用变量时，只能访问超类定义的字段和方法
但是，是被引用对象的类型而不是引用变量的类型决定执行哪个版本的重载方法
也就是说，决定调用哪个版本的方法取决于对象的真正的类型(class)

注：
1，若子类和父类不能通过is-a测试，则说明使用继承是不正确的。
2，子类若要override父类的某个方法，最好是增加自己新的功能而不是完全重写
这就意味着应该在覆盖的方法中使用super调用父类的该方法，如果完全重写的话需要
考虑子类是否真的适合于继承父类，因为它改变了父类的某些信息。