                                 equals 和 hashCode

Map使用equals()判断当前的"键"是否与表中存在的"键"相同
默认的Object.equals()只是比较对象的地址
若是使用自己的类作为Map的"键"则必须同时重载equals()和hashCode()

正确的equals()方法必须满足下列5个条件：
1，自反性。对任意x，x.equals(x)一定返回true
2，对称性。对任意的x和y，x.equals(y)和y.equals(x)结果必须一致
3，传递性。对任意的x、y、z，如果有x.equals(y)返回true
   y.equals(z)返回true，则x.equals(z)一定返回true
4，一致性。对任意的x和y，无论调用多少次x.equals(y)返回结果保持一致
5，对任何不是null的x，x.equals(null)一定返回false

编写一个完美的equals方法的建议：
1，传入的参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。
2，检测this与otherObject是否引用同一个对象：
if(this == otherObject) return true;
这条语句只是一个优化。实际上这是一种经常采用个形式。
因为计算这个等式要比一个一个的比较类中的域所付出的代价小得多。
3，检测otherObject是否为null，如果为null则返回false：
if(otherObject == null) return false;
比较this与otherObject是否属于同一个类：
如果equals的语义在每个子类中有所改变，就使用getClass检测：
if(getClass != otherObject.getClass) return false;
如果所有的子类都拥有统一的语义，就是用instanceof检测：
if(!(otherObject instanceof ClassName)) return false;
4，将otherObject转换为相应的类类型变量：
ClassName other = (ClassName) otherObject;
5，开始对所有需要比较的域进行比较，如果所有的域都匹配，就返回true，否则返回false。
如果在子类中重新定义equals，就要在其中包含调用super.equals(other)


设计hashCode()时最重要的因素是：
无论何时，同一个对象调用hashCode()都应该产生相同的值
不应该使hashCode()依赖于具有唯一性的对象信息，尤其是this的值
应该使用对象内有意义的识别信息,必须基于对象的内容生成hashCode

规范的hashCode()方法基本流程：
1，给int变量result赋予某个非零值常量，例如17
2，为对象内每个有意义的字段f(即每个可以做equals()操作的字段)计算出一个int散列码c
      字段类型                              计算
    boolean                         c=(f?0:1) 
byte、char、short、int               c=(int)f
     long                           c=(int)(f^(f>>>32))
     float                          c=Float.floatToIntBits(f)
     double                         long l=Double.doubleToLongBits(f)
                                    c=(int)(l^(l>>>32))
     Object                         c=f.hashCode()
       数组                               对每个元素应用上述规则
3，合并计算得到的散列码：result=37*result+c;
4，返回result
5，检查hashCode()最后生成的结果，确保相同的对象有相同的散列码

equals与hashCode的定义必须一致：
如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()具有相同的值。