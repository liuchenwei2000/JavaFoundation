                            Object.clone()详解

                            
Object.clone()能够按对象大小创建足够的内存空间，并把旧对象的所有比特位复制到新对象。
这被称为"逐位复制(bitwise copy)"，它正是你期望的 clone()方法的典型行为。
但是Object.clone()在执行前，会先检查此类是否可克隆(是否实现了Cloneable接口)。
如果没有实现此接口，Object.clone()会抛出CloneNotSupportedException异常，说明它不能被克隆。

调用Object.clone()时实际会发生什么，致使覆盖clone()时必须要调用super.clone()呢？
Object类的clone()方法负责创建正确容量的存储空间，并作"逐位复制"，由原对象复制到新对象的存储空间中。
也就是说，它并不是仅仅创建存储空间，然后复制一个Object。
它实际是计算出即将复制的真实对象的大小(不只是基类对象，还包括源于它的对象)。
由于这都发生在根类定义的clone()方法中(它并不知道谁会继承它)，所以是RTTI机制确定要被克隆的实际对象。
通过这种方式，clone()方法能够创建合适的存储空间，正确地"逐位复制"你的类型。
无论怎样做，克隆过程的第一步通常都是调用super.clone()。
它制作出完全相同的副本，为克隆操作建立了基础。
在此基础上，你可以执行对完成克隆必要的其他操作。

Object.clone()实际上是浅克隆，因此通常你会在可克隆类的每个子类中调用super.clone()
以保证基类所有的操作(包括Object.clone())都被执行。然后，对对象中的每个引用，都明确地调用 clone()。
否则那些引用会被别名化，仍指向原本的对象。这与调用构造器的方式类似：
基类的构造器先执行，然后是其直接继承者，依此类推，直到最末端子类的构造器。
可惜clone()不是构造器，这不会自动发生，你必须自己处理这个过程。