                                                                                       使类具有克隆能力


虽然是在所有类的基类Object中定义了克隆方法，但也不是每个类都自动具有克隆能力。
如果一个类需要具有克隆能力，必须专门添加一些代码，它才能够克隆：

1，使用protected的技巧
为防止所有类缺省地就具备克隆能力，基类中的clone()方法被声明为 protected。
这意味着，对使用(而非继承)此类的客户端程序员，克隆方法不再是缺省地可用。
此方法让你在编译期就知道，你的对象不具备克隆能力。
而且，标准Java类库中的大多数类都不可克隆。

因为Object.clone()是 protected，所以在 Object的子类内部，你有权限去调用它。
基类的clone()方法很实用，它在"位"( bitwise)级别上复制子类的对象，如同通常的克隆操作一样。
然而，你必须将你的克隆操作声明为public，它才可以被访问。
所以，克隆对象时有两个关键问题：
1，调用super.clone() 
2，将自己的克隆方法声明为public

protected的技巧只能用一次：在第一次继承无克隆能力的类，而又希望它的子类具有克隆能力时。
继承自你的类的任何子类，其clone()方法都可用，因为 Java中，继承无法削减方法的访问权。
既是说，如果某个类是可克隆的，它的继承者也都是可克隆的，除非你使用某种机制"关闭"克隆能力。

2，实现Cloneable接口
要完善一个对象的克隆能力，还需要做一件事：实现Cloneable接口。
实现Cloneable空接口的原因显然不是为了类型转换，然后调用Cloneable接口的方法。
这样使用的接口称为"标记接口(tagging interface)"，因为它像是一种贴在类身上的标记。

Cloneable接口的存在有两个理由：
第一，如果某个引用向上转型为基类后，你就不知道它是否能克隆。
此时，可以使用instanceof关键字检查该引用是否指向一个可克隆的对象。
第二，与克隆能力的设计有关，这是考虑到也许你不愿意所有类型的对象都是可克隆的。
所以Object.clone()会检查当前类是否实现了 Cloneable接口。
如果没有，它抛出CloneNotSupportedException异常。
所以，作为实现克隆能力的一部分，通常你必须实现Cloneable接口。