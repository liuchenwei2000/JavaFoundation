                                                                                 只 读 类 的 由 来


虽然在适当的情况下，clone()生成的局部拷贝可以满足我们的需求，但这是以下情况的典型示例：
它强制程序员(clone()方法的作者)必须负责避免别名的负面效应。
当你开发的类库具有很强的通用性，而你不能假设你的类总是在恰当的位置被克隆时，又会怎么样呢？
或者更可能的情况是，如果你为了效率而允许出现别名――为了避免不必要的复制对象，
但你不想因为别名而产生负面影响，这时又会怎样呢？

一种解决方法是创建"恒常对象(immutable objects)"，它属于只读类。
在你的类中，不要定义会修改对象内部状态的方法。
对于这样的类，出现别名也不会有影响，因为你只能读取对象的内部状态，即使很多代码都读取同一个对象，也没有问题。

恒常性(immutability)的缺点
创建恒常的类，初看起来似乎是一种优雅的解决方案。
然而，无论何时当你需要一个被修改过的此类的对象的时候，必须要承受创建新对象的开销，也会更频繁地引发垃圾回收。
对某些类而言，这不成问题，但对另一些类(例如String类)，其代价可能昂贵得让人不得不禁止这么做。
解决之道是创建一个可以被修改的伴随类(companion class)。
当你需要做大量修改动作时，可以转为使用可修改的伴随类，修改操作完毕后，再转回恒常类。