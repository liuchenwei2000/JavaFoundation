                                                                                       使类具有克隆能力

三种克隆方式：
引用克隆：对象的引用克隆是另一个简单对象变量，它复制了对同一个对象的引用。
浅克隆：按比特的对象克隆，新创建的对象精确的复制了原来对象的值，如果对象的某个属性是其他对象的引用，那么只复制这个引用。
深克隆：对象的完全复制，如果对象有对其它对象的引用，那些对象也被完全复制。

如果只是从对象中读取信息，而不修改对象，那么"传引用"就是传递参数最高效的方式。
但是，有时必须将参数对象视为"局部对象"，才能使方法内的修改只影响局部的副本，从而不会改变方法外的对象。
很多编程语言支持这种可以自动为参数对象创建一份方法内的局部拷贝的能力。Java虽然不支持此能力，但允许产生同样的效果。

需要使用对象的局部拷贝的最可能的原因是：
你必须修改那个对象，但又不希望改动调用者的对象。如果你决定要制做一份局部拷贝，可以使用clone()方法————定义在 Object类中的protected方法。
如果要使用它，必须在子类中以 public方式覆盖此方法。


虽然在所有类的基类Object中定义了克隆方法，但也不是每个类都自动具有克隆能力。
如果一个类需要具有克隆能力，必须专门添加一些代码，它才能够克隆：

1，使用protected的技巧
为防止所有类缺省地就具备克隆能力，基类中的clone()方法被声明为 protected。
这意味着，对使用(而非继承)此类的客户端程序员，克隆方法不再是缺省地可用。
此方法让你在编译期就知道，你的对象不具备克隆能力。而且，标准Java类库中的大多数类都不可克隆。

因为Object.clone()是 protected，所以只有在 Object的子类内部才有权限去调用它。
基类的clone()方法很实用，它在"位"(bitwise)级别上复制子类的对象，如同通常的克隆操作一样。
然而，你必须将你的克隆操作声明为public，它才可以被访问。

所以，克隆对象时有两个关键问题：
1，调用super.clone() 
2，将自己的克隆方法声明为public

protected的技巧只能用一次：在第一次继承无克隆能力的类，而又希望它的子类具有克隆能力时。
继承自你的类的任何子类，其clone()方法都可用，因为 Java中，继承无法削减方法的访问权。
也就是说，如果某个类是可克隆的，它的继承者也都是可克隆的，除非你使用某种机制"关闭"克隆能力。

2，实现Cloneable接口
要完善一个对象的克隆能力，还需要做一件事：实现Cloneable接口。
实现Cloneable空接口的原因显然不是为了类型转换，然后调用Cloneable接口的方法。
这样使用的接口称为"标记接口(tagging interface)"，因为它像是一种贴在类身上的标记。

Cloneable接口的存在有两个理由：
第一，如果某个引用向上转型为基类后，你就不知道它是否能克隆。
此时，可以使用instanceof关键字检查该引用是否指向一个可克隆的对象。
第二，与克隆能力的设计有关，这是考虑到也许你不愿意所有类型的对象都是可克隆的。
所以Object.clone()会检查当前类是否实现了 Cloneable接口。如果没有，它抛出CloneNotSupportedException异常。
