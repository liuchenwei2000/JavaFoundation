## 方法分派 ##

变量被声明时的类型叫做变量的静态类型(static type)，而变量所引用的对象的真实类型叫做变量的实际类型(actual type)。

根据对象的类型而对方法进行的选择，就是分派(dispatch)。分派是面向对象的语言所提供的关键特性之一。根据分派发生的时期，可以将分派分为两种，即静态分派和动态分派。

* 静态分派(static dispatch)发生在编译时期，分派根据静态类型信息发生，方法重载(overload)就是静态分派。
* 动态分派(dynamic dispatch)发生在运行时期，动态分派动态的置换掉某个方法。面向对象的语言利用动态分派来实现方法置换产生的多态性。

问题的核心是Java编译器在编译时期并不总是知道哪一些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。


Java中对象调用方法的执行过程如下：

* 1，编译器查看对象的声明类型和方法名。
编译器将会一一列举对象所属类中的所有具有该方法名的方法和其超类中访问属性为public且具有该方法名的方法。
至此，编译器已获得所有可能被调用的候选方法。

* 2，编译器将查看调用方法时提供的参数类型。
如果在1得到的方法中存在一个其参数类型与提供的参数类型完全匹配，那么就调用这个方法。这个过程叫做重载解析。
至此，编译器已获得需要调用的方法的名字和参数类型。

* 3，如果方法是private、static、final或者构造器，那么编译器将可以准确地知道应该调用哪个方法。
这种调用方式称为静态绑定。与之对应，调用哪个方法将依赖于调用对象的实际类型，并且在运行时动态绑定。

* 4，当程序运行，并且采用动态绑定调用方法时，JVM会调用与调用对象的实际类型最合适的那个类的方法。
每次调用方法都要进行搜索，时间开销相当大。因此，JVM预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。
这样在真正调用方法的时候，JVM仅查找这个表就行了。

动态绑定有一个非常重要的特性：无需对现有的代码进行修改，就可以对程序进行扩展。
