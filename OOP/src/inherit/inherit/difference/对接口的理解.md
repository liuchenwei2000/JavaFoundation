## 对接口的理解 ##

接口的命名一般以able作为结尾，意味可……的。接口中的方法不可以被native, synchronized, strictfp, static, final修饰。
因为这些方法是不关心具体实现的，并且都是抽象的（若一个接口不是public的而是包级访问权限，则它只能在包内使用）


使用接口的三个重要原因是：

* 1，为了能够向上转型为多个基类型以及由此带来的灵活性，也就是实现了多个接口达到多重继承的目的。
* 2，与使用抽象类一样，防止客户端程序员创建该类的实例。
* 3，有时候拘泥于单继承体系会使程序受限很多，如果方法的参数是一个接口，而不是一个类，这种限制就放松了许多。
因为任何实现了该接口的类都能满足该方法，也包括当时不存在的类，这就给予客户端程序员一种选择，它可以通过实现一个接口来满足类或方法。
因此，接口允许我们快捷地实现 类继承，也使得创建一个新实现类就可以做到这一点。


### 接口的其他用途

因为接口中的任何字段都自动的是public static final，所以可以用来很便捷的创建常量组，但这些字段不是接口的一部分，只是被存储在该接口的静态存储区域内（现在可以被Enum取代）。 
当接口中的任何字段首次被访问时，接口类被JVM加载并且初始化所有数据。

有些接口中没有任何的常量和方法，就像是Cloneable接口似的，这种接口被称为标记接口，用来标明实现类应具有的属性或者机制。
这是一种退化了的契约，一般会在相关文档中对该接口做出详细解释。


### 对接口的一些建议

* 1，可以将接口方法标记为public，将常量标记为public static final。
有些程序员出于习惯或高清晰度的考虑，愿意这样做。但Java语言规范却建议不要书写这些多余的关键字。

* 2，常量接口只定义常量而没有任何方法，类为了能够简洁的引用接口中的常量而去实现这个接口的确可行
但是这样应用接口似乎有点偏离接口概念的初衷，不建议这样做。

* 3，标记接口没有方法，使用它的唯一目的是可以用instanceof进行类型检查。
建议在编写程序时，如非必须不要使用这种技术。


### 接口中的 override
                    
如果一个接口继承了另一个接口，并且它有个和父接口一样的方法(返回类型、签名式、参数列都一样)。
那么这个接口的该方法override了父接口的该方法，这样做在语意上没有任何影响，当某个类实现子接口的时候只需要实现该方法一次就够了。
如果一个接口继承了多个接口并且这些父接口中有相同的签名式和参数列表的方法，那么这个子接口只需要定义一个版本的该方法即可，因为它最终会被类来实现。
