                                      Java内存模型

Java在内存分配时会涉及到以下区域：

寄存器：在程序中无法控制。
栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中。
堆：存放用new产生的数据。
静态域：存放在对象中用static定义的静态成员。
常量池：存放常量。
非RAM存储：硬盘等永久存储空间。


栈

在方法定义中的一些基本类型的变量数据和对象的引用变量都在方法的栈内存中分配。
当一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。

堆

堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由JVM的自动垃圾回收器来管理。
在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起了一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。
引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用new产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能再被使用，但仍然占据着内存空间，在随后的一个不确定的时间被垃圾回收器收走释放掉内存。这也是Java比较占内存的原因。

常量池(constant pool)

常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型(如int、double等)和对象型(如String及数组)的常量值(final)还包含一些以文本形式出现的符号引用，比如：
类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。
虚拟机必须为每个被装载的类维护一个常量池。常量池就是该类所用到常量的一个有序集合，包括直接常量(Stirng、int等常量)和对其他类型，字段和方法的符号引用。
对于String常量，它的值是在常量池中的。而JVM中的常量池在内存中是以表的形式存在的，该表只存储文字字符串值，不存储符号引用。


堆和栈的比较

Java的堆是一个运行时数据区，类的对象从中分配空间，它们不需要程序代码来显式的释放，堆是由垃圾回收来负责的。
堆的优势：
可以动态的分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的。垃圾回收器会自动回收这些不再使用的数据内存。
堆的缺点：
由于要在运行时动态分配内存，存取速度较慢。

栈的优势：
存取速度比堆要快，仅次于寄存器，栈数据可以共享。
栈的缺点：
存在栈中的数据大小和生存期必须是确定的，缺乏灵活性。

栈的特殊性

存在栈中的数据可以共享。假设下面的代码：
int a=3;
int b=3;
编译器会先处理int a=3;首先它会在栈中创建一个名称为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b=3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器会重复上述过程。但是a值的改变不会影响到b的值。
要注意这种数据的共享与两个引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改不会影响到b，它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。